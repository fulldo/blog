# React Fiber 文章梳理

## 前言

### 重新认识 React Fiber

### React Fiber 前端领域首次被广泛认知

### 了解 Fiber 有助于了解后续新功能

### React18 之前还是同步渲染

16、17 都是过渡版本

## Fiber 不是新东西

### 进程并发(Concurrent)

- 操作系统根据调度策略
- 分配 CPU 执行权给多个进程
- 多进程交替执行，好像在“同时执行”
- 实际上单核同时只能有一个程序运行
  因为 CPU 太快了感觉在同时运行

### 进程并行

- 需要物理条件支持（多核）

### 进程调度策略

- 多处理器调度
- 单处理器调度
  (类比 JS 运行机制)

      - 先到先得

  (First-Come-First-Served, FCFS)

      	-  对短进程不利
      	- 对I/O密集不利
      	- 在单处理器进程调度中并不受欢迎

      - 轮转

      	- 基于时钟的抢占策略
      	- 每一进程都有固定执行时间
      	- 超时后执行权会被回收
      	- 要点是确定合适的时间片长度

      		- 太长，长进程霸占资源，其他得不到响应
      		- 太短，可能频繁切换，浪费时间

      	- 对I/O密集不利

      - 最短进程优先

  (Shortest Process Next, SPN)

      	- 对进程统计分析
      	- 预估进程执行时间
      	- 对进程进行优先级排序
      	- 先执行完短进程，后执行长进程
      	- 缺点：有大量的短进程，长进程会饥饿
      	- 没解决FCFS长进程问题

      - 最短剩余时间

  (Shortest Remaining Time, SRT)

      	- 优化了SPN，增加了抢占机制
      	- 比较新进程和老进程的‘剩余时间’
      	- 新进程剩余更短，会抢占老进程
      	- 相比轮转的抢占，SRT 没有中断处理的开销
      	- 在 SPN 基础上需记录进程历史执行时间，新开销
      	- 长进程饥饿问题还是没有解决

      - 最高响应比优先(HRRN)

      	- (等待执行时间 + 进程执行时间)/ 进程执行时间
      	- 短进程时间短分母小，所以响应高，被优先执行
      	- 长进程时间长，开始响应比小，随着等待时间增长，优先级会越来越高，最终可以被执行

      - 反馈法

      	- SPN、SRT、HRRN需要对进程时间进行评估和统计，实现比较复杂且需要一定开销
      	- 反馈法采取的是事后反馈的方式
      	- 每个进程一开始都有相同的优先级
      	- 每次被抢占优先级就会降低一级
      	- 仍然可能导致长进程饥饿
      	- 可统计长进程等待时间，超过阈值则提高优先级

## JavaScript 执行环境

### 单线程

- GUI 渲染线程

  - 渲染界面，Style、Layout、Paint、Composite
  - 与 JS 线程互斥

- Javascript 引擎线程

  - 运行脚本
  - 与 GUI 渲染线程互斥

### 解决单线程

- 优化任务，挤压 CPU 运算量，让它有多快就多快

  - Vue 的选择

- 快速响应，让用户觉得够快，不阻塞用户交互

  - React 的选择

- 尝试 Worker 多线程

  - 要保证状态和视图的一致性相当麻烦

## 为什么引入 Fiber 架构？

### React Reconcilation

- 属于 CPU 密集型的操作

  - 相当于’长进程‘
  - 要让高优先级的进程或者短进程优先运行
  - 不能让长进程长期霸占资源

- Stack 架构问题

  - 递归比对 VirtualDOM 树
  - 会霸占着浏览器资源

    - 导致用户触发的事件得不到响应
    - 导致掉帧，用户可以感知到这些卡顿

- 优化

  - 方向

    - 不能让一个程序长期霸占着资源
    - 调度策略合理地分配 CPU 资源

      - 浏览器的渲染、布局、绘制、资源加载
      - 事件响应、脚本执行

    - 提高浏览器的用户响应速率，兼顾任务执行效率

  - 通过 Fiber 架构实现

    - Reconcilation 过程变成可被中断
    - '适时'地让出 CPU 执行权

## 何为 Fiber

### 一种流程控制原语

- 即协程，一种控制流程的让出机制

  - 举例理解协程

    - 普通函数无法被中断和恢复
    - Generator 函数可以

- Fiber 思想

  - 将控制权交回浏览器

    - 执行高优先级的任务

  - 浏览器空闲后再恢复渲染
  - React 渲染的过程可以被中断

- 疑问

  - 浏览器不能抢占， 所以 React 只能用让出机制?

    - 是的，主动让出机制
    - 一是浏览器中没有类似进程的概念

      - 任务间没有上下文，不具备中断/恢复的条件

    - 二是没有抢占的机制

      - 无法中断一个正在执行的程序

    - 所以只能采用类似协程的让出机制

      - 即合作式调度(Cooperative Scheduling)

        - 与抢占式调度(Preemptive Scheduling)对应

      - ’契约‘调度

        - 要求程序和浏览器紧密结合，互相信任
        - 浏览器分配执行时间片
        - 在这个时间内执行完毕，并将控制权还给浏览器
        - 缺点：全凭自律

  - 怎么确定有高优任务要处理，即什么时候让出？

    - 通过 requestIdleCallback API

      - 让浏览器在'有空'的时候执行回调
      - 一帧执行的任务

        - 处理用户输入事件
        - Javascript 执行
        - requestAnimation 调用
        - 布局 Layout
        - 绘制 Paint

      - 目前只有 Chrome 支持，React 自己实现了

        - MessageChannel 模拟

      - 任务优先级

        - Immediate 同步任务，立即执行
        - UserBlocking 需要即时得到反馈
        - Normal
        - Low
        - Idle

    - 通过超时检查的机制来让出控制权

      - 确定一个合理的运行时长
      - 在合适的检查点检测是否超时
      - 超时就停止执行，将控制权交换给浏览器

  - React 那为什么不使用 Generator？

    - 太麻烦了

      - Generator 不能在栈中间让出
      - Generator 是有状态的， 很难在中间恢复

### 一个执行单元

- 一种数据结构或者说执行单元
- 每执行完一个'执行单元'，会检查还剩多少时间

  - 交出执行权，保存现场，等下次有执行权时恢复
  - 充足就进行执行下一个执行单元

## React 的 Fiber 改造

### 数据结构的调整

- 原先的栈结构

  - 结构属性

    - 基本单位：函数
    - 输入：函数参数
    - 本地状态：本地变量
    - 输出：函数返回值
    - 下级：嵌套函数调用
    - 上级引用：返回地址

  - 优点

    - 代码量少，递归容易理解
    - 适合树这种嵌套数据结构的处理

  - 缺点

    - 不能随意中断、也很难被恢复
    - 不利于异步处理

- 改为 Fiber 链表

  - 简介

    - 模拟函数调用栈，递归转换成迭代
    - 和调用栈帧一样, 保存了节点处理的上下文信息

  - 结构属性

    - 基本单位：Virtual DOM 节点
    - 输入：Props
    - 本地状态：State
    - 输出：React Element
    - 下级：子节点(child)
    - 上级引用：父节点(return)

  - 优点

    - 即使被中断也可从上次未处理完的 Fiber 继续遍历

  - 缺点

    - 复杂

### 两个阶段的拆分

- Reconciliation(协调阶段)

      - 找出所有节点变更（新增、删除、属性变更等）
      - 这个阶段可以被中断
      - 生命周期

  (多次重做，不能包含副作用)

      	- constructor
      	- componentWillMount 废弃
      	- componentWillReceiveProps 废弃
      	- static getDerivedStateFromProps
      	- shouldComponentUpdate
      	- componentWillUpdate 废弃
      	- render

- Commit(提交阶段)

      - 将上阶段得到的需要处理的Effects一次性执行了
      - 同步执行，不能被打断
      - 生命周期

  (只执行一次)

      	- getSnapshotBeforeUpdate()

      		- 在进入 commit 阶段前调用

      	- componentDidMount
      	- componentDidUpdate
      	- componentWillUnmount

### Reconcilation

- Fiber 的结构

  - 结构信息

    - return
    - child
    - sibling

  - 节点类型信息

    - tag：节点分类

      - 例如函数组件、类组件、宿主组件

    - type：保存具体的类型值

      - 具体的类组件、函数组件、宿主组件(字符串)
      - 如 div、MyComp

  - 节点的状态

    - stateNode 节点的组件实例

      - 宿主组件保存其实例，如 DOM 节点
      - 对于类组件，保存类组件的实例
      - 函数组件，为空，因为函数组件没有实例

    - pendingProps

      - 新的、待处理的 props

    - memoizedProps

      - 上一次渲染的 props

    - memoizedState

      - 上一次渲染的组件状态

  - 副作用

    - effectTag

      - 当前节点的副作用类型，如更新、删除、移动

    - nextEffect

      - 使用链表来将所有有副作用的 Fiber 连接起来

  - 替身

    - alternate

      - 指向旧树中的节点

- 过程

  - 旧树
  - WIP 树

    - 需要变更的节点，都打上了'标签'
    - 提交阶段将这些打上标签的节点应用变更

### 双缓冲

- 图形绘制引擎一般会使用双缓冲技术

  - 先将图片绘制到一个缓冲区
  - 再一次性传递给屏幕进行显示
  - 可以防止屏幕抖动，优化渲染性能

- React 中，WIP 树就是一个缓冲

  - Reconciliation 完毕后一次性提交给浏览器渲染
  - 减少内存分配和垃圾回收
  - WIP 的节点不完全是新的

    - 如某颗子树不需要变动，直接复用子树

- 异常的处理

  - 当一个节点抛出异常

    - 可以继续沿用旧树的节点

      - 避免整棵树挂掉

### 副作用的收集和提交

_XMind: ZEN - Trial Version_
